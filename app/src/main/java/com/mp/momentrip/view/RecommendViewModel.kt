package com.mp.momentrip.view

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.mp.momentrip.data.place.Place
import com.mp.momentrip.data.schedule.Activity
import com.mp.momentrip.data.schedule.Day
import com.mp.momentrip.data.schedule.Schedule
import com.mp.momentrip.data.tourAPI.ContentType
import com.mp.momentrip.data.user.FoodPreference
import com.mp.momentrip.service.AccountService
import com.mp.momentrip.service.RecommendService
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.time.LocalDate
import java.time.LocalTime
import java.time.temporal.ChronoUnit

data class RecommendInitData(
    val region: String,
    val userVector: List<Float>,
    val foodPreference: FoodPreference
)
class RecommendViewModel : ViewModel() {
    private val _autoGeneratedSchedule = MutableStateFlow<Schedule?>(null)
    val autoGeneratedSchedule: StateFlow<Schedule?> = _autoGeneratedSchedule.asStateFlow()

    private val _recommendFromSimilarUsers = MutableStateFlow<List<Place>?>(null)
    val recommendFromSimilarUsers: StateFlow<List<Place>?> = _recommendFromSimilarUsers.asStateFlow()

    private val _recommendPlacesByCategory = MutableStateFlow<Map<ContentType, List<Place>>>(emptyMap())
    val recommendPlacesByCategory: StateFlow<Map<ContentType, List<Place>>> = _recommendPlacesByCategory.asStateFlow()

    private val _userVector = MutableStateFlow<List<Float>?>(null)
    private val _foodPreference = MutableStateFlow<FoodPreference?>(null)

    val isLoading: StateFlow<Boolean> get() = _isLoading.asStateFlow()
    private val _isLoading = MutableStateFlow(false)

    private var isInitialized = false

    fun initialize(initData: RecommendInitData) {
        if (!isInitialized) {
            _userVector.value = initData.userVector
            _foodPreference.value = initData.foodPreference

            loadFavoriteFoodType()
            loadRecommendPlaces(initData.region)
            loadSimilarUsersPlaces(initData.userVector.toFloatArray())

            isInitialized = true
        }
    }

    private fun loadFavoriteFoodType() {
        viewModelScope.launch {
            val type = RecommendService.getFavoriteFoodType(_foodPreference.value)
            _favoriteFoodType.value = type
        }
    }

    fun loadRecommendPlaces(region: String) {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                val vec = _userVector.value ?: return@launch
                val categorized = RecommendService.getRecommendedPlacesByRegion(vec, region)
                _recommendPlacesByCategory.value = categorized
            } catch (e: Exception) {
                Log.e("RecommendVM", "Ï∂îÏ≤ú Ïã§Ìå®", e)
            } finally {
                _isLoading.value = false
            }
        }
    }

    fun loadSimilarUsersPlaces(userVector: FloatArray) {
        viewModelScope.launch {
            try {
                val uid = AccountService.getCurrentUser()?.uid ?: return@launch
                val places = AccountService.fetchSimilarUsersPlaces(uid, userVector)
                _recommendFromSimilarUsers.value = places
            } catch (e: Exception) {
                Log.e("RecommendVM", "Ïú†ÏÇ¨ ÏÇ¨Ïö©Ïûê Ïû•ÏÜå Ïã§Ìå®", e)
            }
        }
    }
    fun generateAutoSchedule(
        region: String,
        startDate: LocalDate,
        endDate: LocalDate,
        userViewModel: UserViewModel,
        onSuccess: (Schedule) -> Unit
    ) {
        viewModelScope.launch {
            try {
                _isLoading.value = true


                // üîÅ 1. Ï∂îÏ≤ú Ïû•ÏÜå Î°úÎî© (suspend ÏßÅÏ†ë Ìò∏Ï∂ú)
                val vec = _userVector.value ?: return@launch
                val categorized = RecommendService.getRecommendedPlacesByRegion(vec, region)
                _recommendPlacesByCategory.value = categorized

                // üìä 2. Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î∂ÑÎ•ò
                val restaurants = categorized[ContentType.RESTAURANT].orEmpty().shuffled()
                val accommodations = categorized[ContentType.ACCOMMODATION].orEmpty().shuffled()
                val others = categorized
                    .filterKeys { it != ContentType.RESTAURANT && it != ContentType.ACCOMMODATION }
                    .values.flatten()
                    .shuffled()

                // üóì 3. ÏùºÏ†ï ÏÉùÏÑ±
                val duration = ChronoUnit.DAYS.between(startDate, endDate).coerceAtLeast(1)+1

                val days = (0 until duration).map { dayIndex ->
                    val date = startDate.plusDays(dayIndex.toLong())
                    val activities = mutableListOf<Activity>()

                    // üçΩ ÏãùÏÇ¨ ÏãúÍ∞Ñ
                    listOf(8, 12, 18).forEachIndexed { i, hour ->
                        restaurants.getOrNull((dayIndex * 3 + i).toInt())?.let { restaurant ->
                            activities.add(
                                Activity(
                                    startTime = LocalTime.of(hour, 0),
                                    endTime = LocalTime.of(hour, 0).plusHours(1),
                                    place = restaurant
                                )
                            )
                        }
                    }

                    // üèû Í¥ÄÍ¥ë/Í∏∞ÌÉÄ
                    listOf(10, 14, 16).forEachIndexed { i, hour ->
                        others.getOrNull((dayIndex * 3 + i).toInt())?.let { place ->
                            activities.add(
                                Activity(
                                    startTime = LocalTime.of(hour, 0),
                                    endTime = LocalTime.of(hour, 0).plusHours(1),
                                    place = place
                                )
                            )
                        }
                    }

                    // üè® ÏàôÏÜå
                    accommodations.getOrNull(dayIndex.toInt())?.let { accommodation ->
                        activities.add(
                            Activity(
                                startTime = LocalTime.of(20, 0),
                                endTime = LocalTime.of(22, 0),
                                place = accommodation
                            )
                        )
                    }

                    Day(
                        index = dayIndex,
                        date = date,
                        timeTable = activities.sortedBy { it.startTime }
                    )
                }

                val generated =  Schedule(
                    title = "$region Ïó¨Ìñâ ÏùºÏ†ï",
                    region = region,
                    startDate = startDate,
                    endDate = endDate,
                    duration = duration,
                    days = days
                )
                // üì¶ 4. Í≤∞Í≥º Ï†ÄÏû•
                _autoGeneratedSchedule.value =generated
                userViewModel.addScheduleToUser(generated, onSuccess = { onSuccess(generated) }, onError = {})
                onSuccess(generated)


            } catch (e: Exception) {
                Log.e("RecommendVM", "AI ÏùºÏ†ï ÏÉùÏÑ± Ïã§Ìå®", e)
            } finally {
                _isLoading.value = false
            }
        }
    }


    private val _favoriteFoodType = MutableStateFlow<String?>(null)
    val favoriteFoodType: StateFlow<String?> = _favoriteFoodType.asStateFlow()
}
